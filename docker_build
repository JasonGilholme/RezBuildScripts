#!/usr/bin/env python
# docker_build package_name remote_source_archive_url cmake_file install_dir

import argparse
import os
import subprocess


parser = argparse.ArgumentParser()

parser.add_argument("package_name")
parser.add_argument("remote_source_archive_url")
parser.add_argument("cmake_file")
parser.add_argument("install_dir")

parser.add_argument("--build_uid", default=os.environ.get('BUILD_UID', 1000))
parser.add_argument("--build_gid", default=os.environ.get('BUILD_GID', 1000))

args = parser.parse_args()


package_name = args.package_name
remote_source_archive_url = args.remote_source_archive_url
cmake_file = args.cmake_file
install_dir = args.install_dir
rez_repo_dir = os.environ.get('REZ_REPO_PAYLOAD_DIR')
build_uid = args.build_uid
build_gid = args.build_gid

#
# Determine if the source archive has already been downloaded
#
source_archive_name = os.path.basename(remote_source_archive_url)
local_source_archive_dir = os.path.join(rez_repo_dir, package_name)
local_source_archive_url = os.path.join(rez_repo_dir, package_name, source_archive_name)

if not os.path.isfile(local_source_archive_url):
    source_archive_url = remote_source_archive_url
else:
    source_archive_url = os.path.join("/docker_build/src", package_name, source_archive_name)


#
# Build the command to run
#
cmd = "docker run --privileged --rm -t "

# Add env vars
cmd += "-e CMAKE_URL=%s " % (source_archive_url,)
cmd += "-e CMAKE_DOWNLOAD_DIR=%s " % (local_source_archive_dir,)
cmd += "-e BUILD_UID=%s " % (build_uid,)
cmd += "-e BUILD_GID=%s " % (build_gid,)

# Add volumes for build input and output
cmd += "-v %s:/docker_build/src " % (rez_repo_dir,)
cmd += "-v %s:/docker_build/out " % (install_dir,)
cmd += "-v %s:/docker_build/CMakeLists.txt " % (cmake_file,)

# Add volumes for build dependencies
# TODO: add arg and iterate it here

# The docker image to run
cmd += "rez_build"
cmd = cmd.split()


#
# Run the subprocess
#
print '[BUILD CMD]', cmd
proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

while True:
    output = proc.stdout.readline()
    if output == '' and proc.poll() is not None:
        break
    if output:
        print output.strip()
    rc = proc.poll()

os._exit(proc.poll())
